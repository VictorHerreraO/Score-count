# Implementation Plan: Task 61 - Update Database Schema for Point Tracking

**Task ID**: 61
**Status**: APPROVED
**Priority**: High
**Estimated Complexity**: Medium

## Critical Evaluation

### Decision: APPROVE

**Reasoning**:
1. **Real Problem**: The current database schema only stores final match scores (sets won), not point-by-point data. This is a legitimate gap that must be filled to support the Match Details Screen feature.
2. **Clear Benefits**:
   - Enables point-by-point score progression visualization
   - Provides foundation for detailed match analysis
   - Follows Clean Architecture patterns already established in the project
3. **Not Over-Engineering**: This is the minimal schema needed to track detailed scoring. The design is straightforward with proper Room relationships.
4. **Dependency Satisfied**: Task 1.1 is completed - domain models (Set, Point, SetScore) exist and are well-structured.

**Trade-offs**:
- **Database size increase**: Storing every point will increase storage requirements, but this is acceptable for the value provided
- **Migration complexity**: Requires careful migration to preserve existing data, but this is necessary technical work
- **One-way upgrade**: Old app versions won't understand new schema, but this is standard for database migrations

## Task Overview

Update the Room database schema from version 1 to version 2 to support point-by-point tracking with new entities (SetEntity, PointEntity) and relationships. Add winnerId to MatchEntity. Implement migration strategy to preserve existing match data.

## Prerequisites Verification

### Dependencies Met
- ✅ Task 1.1 completed: Domain models exist
  - `/app/src/main/java/com/soyvictorherrera/scorecount/domain/model/Set.kt`
  - `/app/src/main/java/com/soyvictorherrera/scorecount/domain/model/Point.kt`
  - `/app/src/main/java/com/soyvictorherrera/scorecount/domain/model/SetScore.kt`
  - Updated `Match.kt` with `sets: List<Set>` and `winnerId: Int?`
  - Updated `Player.kt` with `color: String?`

### Current State Analysis

**Current Database (v1)**:
- Single table: `matches`
- Fields: id, player_one_name, player_two_name, player_one_score, player_two_score, date
- MatchEntity uses Long for id (auto-generated)
- Match domain model uses String for id

**Domain Models Structure**:
```kotlin
// Set.kt
data class Set(
    val setNumber: Int,
    val points: List<Point>,
    val finalScore: SetScore,
    val winnerId: Int
)

// Point.kt
data class Point(
    val sequence: Int,
    val scorerId: Int,
    val player1Score: Int,
    val player2Score: Int
)

// SetScore.kt
data class SetScore(
    val player1Score: Int,
    val player2Score: Int
)

// Match.kt (updated)
data class Match(
    val id: String,
    val playerOneName: String,
    val playerTwoName: String,
    val playerOneScore: Int,
    val playerTwoScore: Int,
    val date: Long,
    val sets: List<Set> = emptyList(),
    val winnerId: Int? = null
)
```

**Key Observations**:
1. winnerId is Int in Set but Int? (nullable) in Match - migration must handle null
2. Player.id is Int (1 or 2), not UUID
3. MatchEntity uses Long id, Match domain uses String id (conversion happens in repository/mapper)
4. Current database has no migration history (version 1, no migrations)

## Implementation Plan

### Step 1: Create SetEntity
**File**: `/app/src/main/java/com/soyvictorherrera/scorecount/data/database/entity/SetEntity.kt`

**Design Decisions**:
- Use Long for id (auto-generated by Room, consistent with MatchEntity)
- Foreign key to MatchEntity.id with CASCADE delete (when match deleted, sets deleted)
- Index on matchId for efficient queries
- Store finalScoreP1/P2 separately (denormalized but avoids extra joins for common queries)
- winnerId as Int (1 or 2) to match Player.id

**Implementation**:
```kotlin
package com.soyvictorherrera.scorecount.data.database.entity

import androidx.room.ColumnInfo
import androidx.room.Entity
import androidx.room.ForeignKey
import androidx.room.Index
import androidx.room.PrimaryKey

@Entity(
    tableName = "sets",
    foreignKeys = [
        ForeignKey(
            entity = MatchEntity::class,
            parentColumns = ["id"],
            childColumns = ["match_id"],
            onDelete = ForeignKey.CASCADE
        )
    ],
    indices = [Index(value = ["match_id"])]
)
data class SetEntity(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0,

    @ColumnInfo(name = "match_id")
    val matchId: Long,

    @ColumnInfo(name = "set_number")
    val setNumber: Int,

    @ColumnInfo(name = "final_score_p1")
    val finalScoreP1: Int,

    @ColumnInfo(name = "final_score_p2")
    val finalScoreP2: Int,

    @ColumnInfo(name = "winner_id")
    val winnerId: Int
)
```

### Step 2: Create PointEntity
**File**: `/app/src/main/java/com/soyvictorherrera/scorecount/data/database/entity/PointEntity.kt`

**Design Decisions**:
- Use Long for id (auto-generated)
- Foreign key to SetEntity.id with CASCADE delete
- Index on setId for efficient queries
- Store complete state: sequence, scorerId, both player scores
- No separate index on sequence because (setId + sequence) queries will use setId index

**Implementation**:
```kotlin
package com.soyvictorherrera.scorecount.data.database.entity

import androidx.room.ColumnInfo
import androidx.room.Entity
import androidx.room.ForeignKey
import androidx.room.Index
import androidx.room.PrimaryKey

@Entity(
    tableName = "points",
    foreignKeys = [
        ForeignKey(
            entity = SetEntity::class,
            parentColumns = ["id"],
            childColumns = ["set_id"],
            onDelete = ForeignKey.CASCADE
        )
    ],
    indices = [Index(value = ["set_id"])]
)
data class PointEntity(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0,

    @ColumnInfo(name = "set_id")
    val setId: Long,

    @ColumnInfo(name = "sequence")
    val sequence: Int,

    @ColumnInfo(name = "scorer_id")
    val scorerId: Int,

    @ColumnInfo(name = "player1_score")
    val player1Score: Int,

    @ColumnInfo(name = "player2_score")
    val player2Score: Int
)
```

### Step 3: Update MatchEntity
**File**: `/app/src/main/java/com/soyvictorherrera/scorecount/data/database/entity/MatchEntity.kt`

**Changes**:
- Add `winnerId` field (nullable Int to support ties or legacy data)
- Use `@ColumnInfo` annotation for consistency and to specify column name

**Implementation**:
```kotlin
package com.soyvictorherrera.scorecount.data.database.entity

import androidx.room.ColumnInfo
import androidx.room.Entity
import androidx.room.PrimaryKey

@Entity(tableName = "matches")
data class MatchEntity(
    @PrimaryKey(autoGenerate = true) val id: Long = 0,
    @ColumnInfo(name = "player_one_name") val playerOneName: String,
    @ColumnInfo(name = "player_two_name") val playerTwoName: String,
    @ColumnInfo(name = "player_one_score") val playerOneScore: Int,
    @ColumnInfo(name = "player_two_score") val playerTwoScore: Int,
    @ColumnInfo(name = "date") val date: Long,
    @ColumnInfo(name = "winner_id") val winnerId: Int? = null // NEW FIELD
)
```

### Step 4: Define Room Relationships
**File**: `/app/src/main/java/com/soyvictorherrera/scorecount/data/database/entity/MatchWithSets.kt` (NEW)

**Design Decisions**:
- Create data classes for relationship queries
- Nested relationships: Match -> Sets -> Points
- Use @Relation annotation for automatic JOIN queries
- Keep these separate from entities (Room best practice)

**Implementation**:
```kotlin
package com.soyvictorherrera.scorecount.data.database.entity

import androidx.room.Embedded
import androidx.room.Relation

/**
 * Represents a complete match with all sets and points.
 * Used for detailed match queries with full history.
 */
data class MatchWithSets(
    @Embedded
    val match: MatchEntity,

    @Relation(
        parentColumn = "id",
        entityColumn = "match_id",
        entity = SetEntity::class
    )
    val sets: List<SetWithPoints>
)

/**
 * Represents a set with all its points.
 * Intermediate relationship for nested queries.
 */
data class SetWithPoints(
    @Embedded
    val set: SetEntity,

    @Relation(
        parentColumn = "id",
        entityColumn = "set_id"
    )
    val points: List<PointEntity>
)
```

### Step 5: Create Database Migration
**File**: `/app/src/main/java/com/soyvictorherrera/scorecount/data/database/AppDatabase.kt`

**Migration Strategy**:
1. Add winnerId column to matches table (NULL for existing matches)
2. Create sets table with foreign key
3. Create points table with foreign key
4. No data transformation needed (existing matches won't have set/point data)

**Critical Considerations**:
- Existing matches have no winner information - winnerId will be NULL
- Existing matches have no point-by-point data - sets/points tables will be empty for them
- This is acceptable: legacy matches show summary only, new matches show full details
- Migration must be destructive-free: all existing match data preserved

**Implementation**:
```kotlin
package com.soyvictorherrera.scorecount.data.database

import androidx.room.Database
import androidx.room.RoomDatabase
import androidx.room.migration.Migration
import androidx.sqlite.db.SupportSQLiteDatabase
import com.soyvictorherrera.scorecount.data.database.dao.MatchDao
import com.soyvictorherrera.scorecount.data.database.entity.MatchEntity
import com.soyvictorherrera.scorecount.data.database.entity.PointEntity
import com.soyvictorherrera.scorecount.data.database.entity.SetEntity

val MIGRATION_1_2 = object : Migration(1, 2) {
    override fun migrate(database: SupportSQLiteDatabase) {
        // Add winner_id column to matches table
        database.execSQL(
            "ALTER TABLE matches ADD COLUMN winner_id INTEGER DEFAULT NULL"
        )

        // Create sets table
        database.execSQL(
            """
            CREATE TABLE IF NOT EXISTS sets (
                id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
                match_id INTEGER NOT NULL,
                set_number INTEGER NOT NULL,
                final_score_p1 INTEGER NOT NULL,
                final_score_p2 INTEGER NOT NULL,
                winner_id INTEGER NOT NULL,
                FOREIGN KEY(match_id) REFERENCES matches(id) ON DELETE CASCADE
            )
            """.trimIndent()
        )

        // Create index on sets.match_id
        database.execSQL(
            "CREATE INDEX IF NOT EXISTS index_sets_match_id ON sets(match_id)"
        )

        // Create points table
        database.execSQL(
            """
            CREATE TABLE IF NOT EXISTS points (
                id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
                set_id INTEGER NOT NULL,
                sequence INTEGER NOT NULL,
                scorer_id INTEGER NOT NULL,
                player1_score INTEGER NOT NULL,
                player2_score INTEGER NOT NULL,
                FOREIGN KEY(set_id) REFERENCES sets(id) ON DELETE CASCADE
            )
            """.trimIndent()
        )

        // Create index on points.set_id
        database.execSQL(
            "CREATE INDEX IF NOT EXISTS index_points_set_id ON points(set_id)"
        )
    }
}

@Database(
    entities = [
        MatchEntity::class,
        SetEntity::class,
        PointEntity::class
    ],
    version = 2,
    exportSchema = false
)
abstract class AppDatabase : RoomDatabase() {
    abstract fun matchDao(): MatchDao
}
```

### Step 6: Update DataModule to Include Migration
**File**: `/app/src/main/java/com/soyvictorherrera/scorecount/di/DataModule.kt`

**Changes**:
- Add migration to Room database builder
- Use `.addMigrations(MIGRATION_1_2)`

**Implementation**:
```kotlin
@Provides
@Singleton
fun provideAppDatabase(
    @ApplicationContext context: Context
): AppDatabase =
    Room
        .databaseBuilder(
            context,
            AppDatabase::class.java,
            "score-count-database"
        )
        .addMigrations(MIGRATION_1_2) // ADD THIS LINE
        .build()
```

### Step 7: Verify Migration Works

**Testing Strategy**:
1. Install app with v1 database (use existing debug build)
2. Add some test matches
3. Update to v2 database (new build with migration)
4. Verify:
   - App doesn't crash
   - Existing matches still visible
   - New matches can be saved
   - Database schema matches v2

**Manual Verification Query** (using Android Studio Database Inspector):
```sql
-- Verify matches table has winner_id column
PRAGMA table_info(matches);

-- Verify sets table exists
SELECT name FROM sqlite_master WHERE type='table' AND name='sets';

-- Verify points table exists
SELECT name FROM sqlite_master WHERE type='table' AND name='points';

-- Verify existing matches preserved
SELECT * FROM matches;

-- Verify foreign keys
PRAGMA foreign_key_list(sets);
PRAGMA foreign_key_list(points);

-- Verify indices
SELECT name FROM sqlite_master WHERE type='index';
```

## Files to Create

1. **SetEntity.kt** (NEW)
   - Path: `/app/src/main/java/com/soyvictorherrera/scorecount/data/database/entity/SetEntity.kt`
   - Lines: ~35

2. **PointEntity.kt** (NEW)
   - Path: `/app/src/main/java/com/soyvictorherrera/scorecount/data/database/entity/PointEntity.kt`
   - Lines: ~35

3. **MatchWithSets.kt** (NEW)
   - Path: `/app/src/main/java/com/soyvictorherrera/scorecount/data/database/entity/MatchWithSets.kt`
   - Lines: ~30

## Files to Modify

1. **MatchEntity.kt** (UPDATE)
   - Path: `/app/src/main/java/com/soyvictorherrera/scorecount/data/database/entity/MatchEntity.kt`
   - Changes: Add `winnerId: Int? = null` field
   - Lines added: 1

2. **AppDatabase.kt** (UPDATE)
   - Path: `/app/src/main/java/com/soyvictorherrera/scorecount/data/database/AppDatabase.kt`
   - Changes:
     - Add MIGRATION_1_2 object
     - Update @Database annotation (entities list, version = 2)
   - Lines added: ~60

3. **DataModule.kt** (UPDATE)
   - Path: `/app/src/main/java/com/soyvictorherrera/scorecount/di/DataModule.kt`
   - Changes: Add `.addMigrations(MIGRATION_1_2)` to Room builder
   - Lines added: 2 (import + method call)

## Validation Checklist

After implementation, verify:

### Schema Validation
- [ ] SetEntity has all required fields with correct types
- [ ] PointEntity has all required fields with correct types
- [ ] MatchEntity has winnerId field (nullable Int)
- [ ] Foreign keys defined: SetEntity -> MatchEntity, PointEntity -> SetEntity
- [ ] Indices created on match_id (sets table) and set_id (points table)
- [ ] Cascade delete configured (deleting match deletes sets, deleting set deletes points)

### Migration Validation
- [ ] MIGRATION_1_2 defined with correct SQL statements
- [ ] AppDatabase version updated to 2
- [ ] AppDatabase entities list includes all three entities
- [ ] DataModule includes migration in database builder
- [ ] Migration preserves existing match data
- [ ] Migration adds winnerId column to matches (NULL for existing)
- [ ] Migration creates sets table with correct schema
- [ ] Migration creates points table with correct schema
- [ ] Migration creates indices on foreign key columns

### Relationship Validation
- [ ] MatchWithSets correctly defines Match -> Sets relationship
- [ ] SetWithPoints correctly defines Set -> Points relationship
- [ ] @Embedded and @Relation annotations correct
- [ ] Nested relationships work (Match -> Sets -> Points)

### Pattern Validation
- [ ] All entities follow existing naming conventions (snake_case for columns)
- [ ] All entities use @ColumnInfo annotations consistently
- [ ] Foreign key naming matches parent table columns
- [ ] Room best practices followed (separate entities from relationships)

### Build Validation
- [ ] Project builds without errors
- [ ] No Room schema validation warnings
- [ ] Detekt passes (if run)
- [ ] ktlint passes (if run)

## Testing Recommendations

While unit tests are not required for this task (database migration testing typically requires instrumented tests), consider these manual tests:

### Manual Testing Steps
1. **Fresh Install Test**:
   - Uninstall app completely
   - Install new version
   - Verify app launches without crash
   - Verify database created with v2 schema

2. **Migration Test**:
   - Install old version (v1 database)
   - Create 2-3 test matches
   - Install new version (with migration)
   - Verify app launches without crash
   - Verify existing matches still visible
   - Verify database now has sets/points tables

3. **Data Integrity Test**:
   - After migration, verify in Database Inspector:
     - Existing matches have all original fields
     - winnerId is NULL for existing matches
     - sets table exists and is empty (or has data if Task 1.3/1.4 completed)
     - points table exists and is empty

### Future Integration Test Opportunities
Once DAOs and repositories are implemented (Task 1.3), create integration tests:
- Insert match with sets and points
- Query match with relationships
- Verify cascade delete behavior
- Test foreign key constraints

## Potential Issues & Mitigations

### Issue 1: Migration Fails on Existing Databases
**Symptom**: App crashes on launch after update with "IllegalStateException: Migration didn't properly handle"
**Cause**: SQL syntax error in migration or schema mismatch
**Mitigation**:
- Thoroughly test SQL statements in SQLite before implementing
- Use Database Inspector to verify schema after migration
- Include fallback: `.fallbackToDestructiveMigration()` during development only

### Issue 2: Foreign Key Constraints Not Enforced
**Symptom**: Orphaned records in sets/points tables
**Cause**: Foreign keys disabled by default in SQLite
**Mitigation**: Room automatically enables foreign keys, but verify with `PRAGMA foreign_keys;`

### Issue 3: Performance Degradation with Nested Queries
**Symptom**: Slow queries when loading matches with full history
**Cause**: N+1 query problem or missing indices
**Mitigation**:
- Indices already included on foreign key columns
- Room @Relation uses efficient JOINs automatically
- Consider pagination for large datasets (future enhancement)

### Issue 4: Detekt Warnings for Long Parameter Lists
**Symptom**: Detekt fails with LongParameterList warning
**Cause**: SetEntity has 6 parameters
**Mitigation**: This is acceptable for data classes. Add suppression if needed: `@Suppress("LongParameterList")`

## Success Criteria

This task is complete when:

1. ✅ SetEntity created with all required fields and proper Room annotations
2. ✅ PointEntity created with all required fields and proper Room annotations
3. ✅ MatchEntity updated with winnerId field
4. ✅ Foreign key relationships defined (SetEntity -> MatchEntity, PointEntity -> SetEntity)
5. ✅ Cascade delete configured for relationships
6. ✅ Indices created on foreign key columns
7. ✅ MatchWithSets and SetWithPoints relationship classes created
8. ✅ Database version updated to 2 in @Database annotation
9. ✅ MIGRATION_1_2 implemented with correct SQL
10. ✅ Migration added to Room database builder in DataModule
11. ✅ Project builds successfully
12. ✅ Migration tested: existing data preserved, new tables created
13. ✅ Database schema follows existing patterns and conventions

## Dependencies for Next Tasks

This task blocks:
- **Task 1.3**: Update DAOs and repositories (requires entities to exist)
- **Task 1.4**: Update score tracking (requires schema to persist data)

This task enables:
- Repository implementation to query matches with full set/point history
- DAO methods to insert sets and points
- Complete data persistence for point-by-point tracking

## Estimated Implementation Time

- SetEntity creation: 15 minutes
- PointEntity creation: 15 minutes
- MatchEntity update: 5 minutes
- Relationship classes: 20 minutes
- Migration implementation: 30 minutes
- DataModule update: 5 minutes
- Testing & verification: 30 minutes
- **Total: ~2 hours**

## Notes for Builder Agent

1. **SQL Formatting**: Use `.trimIndent()` for multi-line SQL strings for readability
2. **Column Naming**: Follow existing pattern (snake_case: player_one_name, not playerOneName)
3. **Null Safety**: winnerId is nullable - use `Int?` not `Int`
4. **Auto-increment**: Room requires `= 0` as default for auto-generated primary keys
5. **Import Order**: Follow project conventions (alphabetical, separated by package)
6. **No Tests**: This task focuses on schema changes. DAO/Repository tests come in Task 1.3
7. **Verification**: Use Android Studio's Database Inspector to verify schema after migration
8. **Git Commit**: Make incremental commits (entities first, then migration, then module update)

## References

- Room Database Documentation: https://developer.android.com/training/data-storage/room
- Room Migrations Guide: https://developer.android.com/training/data-storage/room/migrating-db-versions
- Existing MatchEntity: `/app/src/main/java/com/soyvictorherrera/scorecount/data/database/entity/MatchEntity.kt`
- Existing AppDatabase: `/app/src/main/java/com/soyvictorherrera/scorecount/data/database/AppDatabase.kt`
- Domain Models: `/app/src/main/java/com/soyvictorherrera/scorecount/domain/model/`
- Implementation Guide: `/match_details_screen/IMPLEMENTATION_GUIDE.md`
